/*
    Author: Chandler Stubbs
    Date: Apr 1, 2022
    Description:
        Template node file. Handles the callback functions and other do-somethings as necessary.
*/

#include <chrono>

#include "template/template_node.hpp"
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace std::chrono_literals; // Needed for "100ms" in the wall timer

// Template node constructor takes in the node handle, nh, and then 
// assigns the class variable nh_ to the value of nh. This passes the node
// handle generated by template_ros.cpp so that this file can create the 
// the publishers, subscribers, etc.
TemplateNode::TemplateNode(rclcpp::Node::SharedPtr nh)
    : nh_(nh), count_(0)
{
    // Creating the publisher that publishes a String to the topic "hello_world_counter".
    // The 10 tells the publisher to keep the last 10 published values in the
    // event that messages can not be delivered.
    publisher_ = nh_->create_publisher<std_msgs::msg::String>("hello_world_counter", 10);
    
    // Creating a timer that calls the step() function once every 100ms.
    timer_ = nh_->create_wall_timer(100ms, std::bind(&TemplateNode::step, this));
}

void TemplateNode::step()
{
    // Creates a local variable "message" that is a std_msg String. Auto automatically
    // detects what c++ data type that "message" needs to be.
    auto message = std_msgs::msg::String();

    // Set the data field of message to be Hellow, world! with an incrementing int
    message.data = "Hello, world! " + std::to_string(count_++);

    // Broadcasts a message of urgency level "info" to the console. Also keeps
    // a log of the messages that are broadcast under /opt/ros/foxy/ somewhere.
    RCLCPP_INFO(nh_->get_logger(), "Publisher: '%s'", message.data.c_str());
    
    // Actually publishes the message to the proper topic name.
    publisher_->publish(message);
}
